commit 54cdf9ee305027b88eb515029d690bd2edb5edfc
Author: Dmitry Kalinkin <dmitry.kalinkin@gmail.com>
Date:   Mon Jun 5 07:26:12 2017 -0400

    ReaderYODA: support for reading of gzip compressed files

diff --git a/configure.ac b/configure.ac
index c22977a..5a972e1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -59,6 +59,9 @@ if test x$enable_debug = xyes; then
 fi
 
 
+## Optional zlib support
+AX_CHECK_ZLIB
+
 ## Optional ROOT compatibility
 AC_ARG_ENABLE([root], [AC_HELP_STRING(--disable-root,
   [don't try to build YODA interface to PyROOT (needs root-config) @<:@default=yes@:>@])], [], [enable_root=yes])
diff --git a/m4/ax_check_zlib.m4 b/m4/ax_check_zlib.m4
new file mode 100644
index 0000000..be91a86
--- /dev/null
+++ b/m4/ax_check_zlib.m4
@@ -0,0 +1,142 @@
+# ===========================================================================
+#      https://www.gnu.org/software/autoconf-archive/ax_check_zlib.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CHECK_ZLIB([action-if-found], [action-if-not-found])
+#
+# DESCRIPTION
+#
+#   This macro searches for an installed zlib library. If nothing was
+#   specified when calling configure, it searches first in /usr/local and
+#   then in /usr, /opt/local and /sw. If the --with-zlib=DIR is specified,
+#   it will try to find it in DIR/include/zlib.h and DIR/lib/libz.a. If
+#   --without-zlib is specified, the library is not searched at all.
+#
+#   If either the header file (zlib.h) or the library (libz) is not found,
+#   shell commands 'action-if-not-found' is run. If 'action-if-not-found' is
+#   not specified, the configuration exits on error, asking for a valid zlib
+#   installation directory or --without-zlib.
+#
+#   If both header file and library are found, shell commands
+#   'action-if-found' is run. If 'action-if-found' is not specified, the
+#   default action appends '-I${ZLIB_HOME}/include' to CPFLAGS, appends
+#   '-L$ZLIB_HOME}/lib' to LDFLAGS, prepends '-lz' to LIBS, and calls
+#   AC_DEFINE(HAVE_LIBZ). You should use autoheader to include a definition
+#   for this symbol in a config.h file. Sample usage in a C/C++ source is as
+#   follows:
+#
+#     #ifdef HAVE_LIBZ
+#     #include <zlib.h>
+#     #endif /* HAVE_LIBZ */
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Loic Dachary <loic@senga.org>
+#   Copyright (c) 2010 Bastien Chevreux <bach@chevreux.org>
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation; either version 2 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 15
+
+AU_ALIAS([CHECK_ZLIB], [AX_CHECK_ZLIB])
+AC_DEFUN([AX_CHECK_ZLIB],
+#
+# Handle user hints
+#
+[AC_MSG_CHECKING(if zlib is wanted)
+zlib_places="/usr/local /usr /opt/local /sw"
+AC_ARG_WITH([zlib],
+[  --with-zlib=DIR         root directory path of zlib installation @<:@defaults to
+                          /usr/local or /usr if not found in /usr/local@:>@
+  --without-zlib          to disable zlib usage completely],
+[if test "$withval" != no ; then
+  AC_MSG_RESULT(yes)
+  if test -d "$withval"
+  then
+    zlib_places="$withval $zlib_places"
+  else
+    AC_MSG_WARN([Sorry, $withval does not exist, checking usual places])
+  fi
+else
+  zlib_places=
+  AC_MSG_RESULT(no)
+fi],
+[AC_MSG_RESULT(yes)])
+
+#
+# Locate zlib, if wanted
+#
+if test -n "${zlib_places}"
+then
+	# check the user supplied or any other more or less 'standard' place:
+	#   Most UNIX systems      : /usr/local and /usr
+	#   MacPorts / Fink on OSX : /opt/local respectively /sw
+	for ZLIB_HOME in ${zlib_places} ; do
+	  if test -f "${ZLIB_HOME}/include/zlib.h"; then break; fi
+	  ZLIB_HOME=""
+	done
+
+  ZLIB_OLD_LDFLAGS=$LDFLAGS
+  ZLIB_OLD_CPPFLAGS=$CPPFLAGS
+  if test -n "${ZLIB_HOME}"; then
+        LDFLAGS="$LDFLAGS -L${ZLIB_HOME}/lib"
+        CPPFLAGS="$CPPFLAGS -I${ZLIB_HOME}/include"
+  fi
+  AC_LANG_SAVE
+  AC_LANG_C
+  AC_CHECK_LIB([z], [inflateEnd], [zlib_cv_libz=yes], [zlib_cv_libz=no])
+  AC_CHECK_HEADER([zlib.h], [zlib_cv_zlib_h=yes], [zlib_cv_zlib_h=no])
+  AC_LANG_RESTORE
+  if test "$zlib_cv_libz" = "yes" && test "$zlib_cv_zlib_h" = "yes"
+  then
+    #
+    # If both library and header were found, action-if-found
+    #
+    m4_ifblank([$1],[
+                CPPFLAGS="$CPPFLAGS -I${ZLIB_HOME}/include"
+                LDFLAGS="$LDFLAGS -L${ZLIB_HOME}/lib"
+                LIBS="-lz $LIBS"
+                AC_DEFINE([HAVE_LIBZ], [1],
+                          [Define to 1 if you have `z' library (-lz)])
+               ],[
+                # Restore variables
+                LDFLAGS="$ZLIB_OLD_LDFLAGS"
+                CPPFLAGS="$ZLIB_OLD_CPPFLAGS"
+                $1
+               ])
+  else
+    #
+    # If either header or library was not found, action-if-not-found
+    #
+    m4_default([$2],[
+                AC_MSG_ERROR([either specify a valid zlib installation with --with-zlib=DIR or disable zlib usage with --without-zlib])
+                ])
+  fi
+fi
+])
diff --git a/src/Reader.cc b/src/Reader.cc
index 777a2ac..7c31794 100644
--- a/src/Reader.cc
+++ b/src/Reader.cc
@@ -7,6 +7,7 @@
 #include "YODA/ReaderYODA.h"
 #include "YODA/ReaderAIDA.h"
 #include "YODA/ReaderFLAT.h"
+#include "YODA/Config/DummyConfig.h"
 
 using namespace std;
 
@@ -15,11 +16,20 @@ namespace YODA {
 
   Reader& mkReader(const string& name) {
     const size_t lastdot = name.find_last_of(".");
+    const size_t lastbutonedot = (lastdot == string::npos) ? string::npos : name.find_last_of(".", lastdot-1);
     const string fmt = Utils::toLower((lastdot == string::npos) ? name : name.substr(lastdot+1));
+    const string fmtex = Utils::toLower((lastbutonedot == string::npos) ? name : name.substr(lastbutonedot+1));
     // cout << "File extension: " << fmt << endl;
     if (fmt == "yoda") return ReaderYODA::create();
     if (fmt == "aida") return ReaderAIDA::create();
     if (fmt == "dat" || fmt == "flat")  return ReaderFLAT::create();
+    if (fmtex == "yoda.gz") {
+#ifdef HAVE_LIBZ
+        return ReaderYODA::create();
+#else
+        throw UserError("YODA was compiled without zlib support");
+#endif /* HAVE_LIBZ */
+    }
     throw UserError("Format cannot be identified from string '" + name + "'");
   }
 
diff --git a/src/ReaderYODA.cc b/src/ReaderYODA.cc
index c983e76..f3bc0d7 100644
--- a/src/ReaderYODA.cc
+++ b/src/ReaderYODA.cc
@@ -7,6 +7,7 @@
 #include "YODA/Utils/StringUtils.h"
 #include "YODA/Utils/getline.h"
 #include "YODA/Exceptions.h"
+#include "YODA/Config/DummyConfig.h"
 
 #include "YODA/Counter.h"
 #include "YODA/Histo1D.h"
@@ -20,10 +21,21 @@
 #include <iostream>
 using namespace std;
 
+#ifdef HAVE_LIBZ
+#define _XOPEN_SOURCE 700
+#include "zstr/src/zstr.hpp"
+#endif /* HAVE_LIBZ */
+
 namespace YODA {
 
 
-  void ReaderYODA::read(istream& stream, vector<AnalysisObject*>& aos) {
+  void ReaderYODA::read(istream& _stream, vector<AnalysisObject*>& aos) {
+
+#ifdef HAVE_LIBZ
+    zstr::istream stream(_stream);
+#else
+    auto& stream = _stream;
+#endif /* HAVE_LIBZ */
 
     // Data format parsing states, representing current data type
     /// @todo Extension to e.g. "bar" or multi-counter or binned-value types, and new formats for extended Scatter types
diff --git a/src/zstr/LICENSE b/src/zstr/LICENSE
new file mode 100644
index 0000000..841c721
--- /dev/null
+++ b/src/zstr/LICENSE
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2015 Matei David, Ontario Institute for Cancer Research
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE. 
diff --git a/src/zstr/src/strict_fstream.hpp b/src/zstr/src/strict_fstream.hpp
new file mode 100644
index 0000000..21173c7
--- /dev/null
+++ b/src/zstr/src/strict_fstream.hpp
@@ -0,0 +1,202 @@
+#ifndef __STRICT_FSTREAM_HPP
+#define __STRICT_FSTREAM_HPP
+
+#include <cassert>
+#include <fstream>
+#include <cstring>
+#include <string>
+
+/**
+ * This namespace defines wrappers for std::ifstream, std::ofstream, and
+ * std::fstream objects. The wrappers perform the following steps:
+ * - check the open modes make sense
+ * - check that the call to open() is successful
+ * - (for input streams) check that the opened file is peek-able
+ * - turn on the badbit in the exception mask
+ */
+namespace strict_fstream
+{
+
+/// Overload of error-reporting function, to enable use with VS.
+/// Ref: http://stackoverflow.com/a/901316/717706
+static std::string strerror()
+{
+    std::string buff(80, '\0');
+#ifdef _WIN32
+    if (strerror_s(&buff[0], buff.size(), errno) != 0)
+    {
+        buff = "Unknown error";
+    }
+#elif (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE
+// XSI-compliant strerror_r()
+    if (strerror_r(errno, &buff[0], buff.size()) != 0)
+    {
+        buff = "Unknown error";
+    }
+#else
+// GNU-specific strerror_r()
+    auto p = strerror_r(errno, &buff[0], buff.size());
+    std::string tmp(p, std::strlen(p));
+    std::swap(buff, tmp);
+#endif
+    buff.resize(buff.find('\0'));
+    return buff;
+}
+
+/// Exception class thrown by failed operations.
+class Exception
+    : public std::exception
+{
+public:
+    Exception(const std::string& msg) : _msg(msg) {}
+    const char * what() const noexcept { return _msg.c_str(); }
+private:
+    std::string _msg;
+}; // class Exception
+
+namespace detail
+{
+
+struct static_method_holder
+{
+    static std::string mode_to_string(std::ios_base::openmode mode)
+    {
+        static const int n_modes = 6;
+        static const std::ios_base::openmode mode_val_v[n_modes] =
+            {
+                std::ios_base::in,
+                std::ios_base::out,
+                std::ios_base::app,
+                std::ios_base::ate,
+                std::ios_base::trunc,
+                std::ios_base::binary
+            };
+
+        static const char * mode_name_v[n_modes] =
+            {
+                "in",
+                "out",
+                "app",
+                "ate",
+                "trunc",
+                "binary"
+            };
+        std::string res;
+        for (int i = 0; i < n_modes; ++i)
+        {
+            if (mode & mode_val_v[i])
+            {
+                res += (! res.empty()? "|" : "");
+                res += mode_name_v[i];
+            }
+        }
+        if (res.empty()) res = "none";
+        return res;
+    }
+    static void check_mode(const std::string& filename, std::ios_base::openmode mode)
+    {
+        if ((mode & std::ios_base::trunc) && ! (mode & std::ios_base::out))
+        {
+            throw Exception(std::string("strict_fstream: open('") + filename + "'): mode error: trunc and not out");
+        }
+        else if ((mode & std::ios_base::app) && ! (mode & std::ios_base::out))
+        {
+            throw Exception(std::string("strict_fstream: open('") + filename + "'): mode error: app and not out");
+        }
+        else if ((mode & std::ios_base::trunc) && (mode & std::ios_base::app))
+        {
+            throw Exception(std::string("strict_fstream: open('") + filename + "'): mode error: trunc and app");
+        }
+     }
+    static void check_open(std::ios * s_p, const std::string& filename, std::ios_base::openmode mode)
+    {
+        if (s_p->fail())
+        {
+            throw Exception(std::string("strict_fstream: open('")
+                            + filename + "'," + mode_to_string(mode) + "): open failed: "
+                            + strerror());
+        }
+    }
+    static void check_peek(std::istream * is_p, const std::string& filename, std::ios_base::openmode mode)
+    {
+        bool peek_failed = true;
+        try
+        {
+            is_p->peek();
+            peek_failed = is_p->fail();
+        }
+        catch (std::ios_base::failure e) {}
+        if (peek_failed)
+        {
+            throw Exception(std::string("strict_fstream: open('")
+                            + filename + "'," + mode_to_string(mode) + "): peek failed: "
+                            + strerror());
+        }
+        is_p->clear();
+    }
+}; // struct static_method_holder
+
+} // namespace detail
+
+class ifstream
+    : public std::ifstream
+{
+public:
+    ifstream() = default;
+    ifstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
+    {
+        open(filename, mode);
+    }
+    void open(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
+    {
+        mode |= std::ios_base::in;
+        exceptions(std::ios_base::badbit);
+        detail::static_method_holder::check_mode(filename, mode);
+        std::ifstream::open(filename, mode);
+        detail::static_method_holder::check_open(this, filename, mode);
+        detail::static_method_holder::check_peek(this, filename, mode);
+    }
+}; // class ifstream
+
+class ofstream
+    : public std::ofstream
+{
+public:
+    ofstream() = default;
+    ofstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::out)
+    {
+        open(filename, mode);
+    }
+    void open(const std::string& filename, std::ios_base::openmode mode = std::ios_base::out)
+    {
+        mode |= std::ios_base::out;
+        exceptions(std::ios_base::badbit);
+        detail::static_method_holder::check_mode(filename, mode);
+        std::ofstream::open(filename, mode);
+        detail::static_method_holder::check_open(this, filename, mode);
+    }
+}; // class ofstream
+
+class fstream
+    : public std::fstream
+{
+public:
+    fstream() = default;
+    fstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
+    {
+        open(filename, mode);
+    }
+    void open(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
+    {
+        if (! (mode & std::ios_base::out)) mode |= std::ios_base::in;
+        exceptions(std::ios_base::badbit);
+        detail::static_method_holder::check_mode(filename, mode);
+        std::fstream::open(filename, mode);
+        detail::static_method_holder::check_open(this, filename, mode);
+        detail::static_method_holder::check_peek(this, filename, mode);
+    }
+}; // class fstream
+
+} // namespace strict_fstream
+
+#endif
diff --git a/src/zstr/src/zstr.hpp b/src/zstr/src/zstr.hpp
new file mode 100644
index 0000000..6b63372
--- /dev/null
+++ b/src/zstr/src/zstr.hpp
@@ -0,0 +1,411 @@
+//---------------------------------------------------------
+// Copyright 2015 Ontario Institute for Cancer Research
+// Written by Matei David (matei@cs.toronto.edu)
+//---------------------------------------------------------
+
+// Reference:
+// http://stackoverflow.com/questions/14086417/how-to-write-custom-input-stream-in-c
+
+#ifndef __ZSTR_HPP
+#define __ZSTR_HPP
+
+#include <cassert>
+#include <fstream>
+#include <sstream>
+#include <zlib.h>
+#include "strict_fstream.hpp"
+
+namespace zstr
+{
+
+/// Exception class thrown by failed zlib operations.
+class Exception
+    : public std::exception
+{
+public:
+    Exception(z_stream * zstrm_p, int ret)
+        : _msg("zlib: ")
+    {
+        switch (ret)
+        {
+        case Z_STREAM_ERROR:
+            _msg += "Z_STREAM_ERROR: ";
+            break;
+        case Z_DATA_ERROR:
+            _msg += "Z_DATA_ERROR: ";
+            break;
+        case Z_MEM_ERROR:
+            _msg += "Z_MEM_ERROR: ";
+            break;
+        case Z_VERSION_ERROR:
+            _msg += "Z_VERSION_ERROR: ";
+            break;
+        case Z_BUF_ERROR:
+            _msg += "Z_BUF_ERROR: ";
+            break;
+        default:
+            std::ostringstream oss;
+            oss << ret;
+            _msg += "[" + oss.str() + "]: ";
+            break;
+        }
+        _msg += zstrm_p->msg;
+    }
+    Exception(const std::string msg) : _msg(msg) {}
+    const char * what() const noexcept { return _msg.c_str(); }
+private:
+    std::string _msg;
+}; // class Exception
+
+namespace detail
+{
+
+class z_stream_wrapper
+    : public z_stream
+{
+public:
+    z_stream_wrapper(bool _is_input = true, int _level = Z_DEFAULT_COMPRESSION)
+        : is_input(_is_input)
+    {
+        this->zalloc = Z_NULL;
+        this->zfree = Z_NULL;
+        this->opaque = Z_NULL;
+        int ret;
+        if (is_input)
+        {
+            this->avail_in = 0;
+            this->next_in = Z_NULL;
+            ret = inflateInit2(this, 15+32);
+        }
+        else
+        {
+            ret = deflateInit2(this, _level, Z_DEFLATED, 15+16, 8, Z_DEFAULT_STRATEGY);
+        }
+        if (ret != Z_OK) throw Exception(this, ret);
+    }
+    ~z_stream_wrapper()
+    {
+        if (is_input)
+        {
+            inflateEnd(this);
+        }
+        else
+        {
+            deflateEnd(this);
+        }
+    }
+private:
+    bool is_input;
+}; // class z_stream_wrapper
+
+} // namespace detail
+
+class istreambuf
+    : public std::streambuf
+{
+public:
+    istreambuf(std::streambuf * _sbuf_p,
+               std::size_t _buff_size = default_buff_size, bool _auto_detect = true)
+        : sbuf_p(_sbuf_p),
+          zstrm_p(nullptr),
+          buff_size(_buff_size),
+          auto_detect(_auto_detect),
+          auto_detect_run(false),
+          is_text(false)
+    {
+        assert(sbuf_p);
+        in_buff = new char [buff_size];
+        in_buff_start = in_buff;
+        in_buff_end = in_buff;
+        out_buff = new char [buff_size];
+        setg(out_buff, out_buff, out_buff);
+    }
+
+    istreambuf(const istreambuf &) = delete;
+    istreambuf(istreambuf &&) = default;
+    istreambuf & operator = (const istreambuf &) = delete;
+    istreambuf & operator = (istreambuf &&) = default;
+
+    virtual ~istreambuf()
+    {
+        delete [] in_buff;
+        delete [] out_buff;
+        if (zstrm_p) delete zstrm_p;
+    }
+
+    virtual std::streambuf::int_type underflow()
+    {
+        if (this->gptr() == this->egptr())
+        {
+            // pointers for free region in output buffer
+            char * out_buff_free_start = out_buff;
+            do
+            {
+                // read more input if none available
+                if (in_buff_start == in_buff_end)
+                {
+                    // empty input buffer: refill from the start
+                    in_buff_start = in_buff;
+                    std::streamsize sz = sbuf_p->sgetn(in_buff, buff_size);
+                    in_buff_end = in_buff + sz;
+                    if (in_buff_end == in_buff_start) break; // end of input
+                }
+                // auto detect if the stream contains text or deflate data
+                if (auto_detect && ! auto_detect_run)
+                {
+                    auto_detect_run = true;
+                    unsigned char b0 = *reinterpret_cast< unsigned char * >(in_buff_start);
+                    unsigned char b1 = *reinterpret_cast< unsigned char * >(in_buff_start + 1);
+                    // Ref:
+                    // http://en.wikipedia.org/wiki/Gzip
+                    // http://stackoverflow.com/questions/9050260/what-does-a-zlib-header-look-like
+                    is_text = ! (in_buff_start + 2 <= in_buff_end
+                                 && ((b0 == 0x1F && b1 == 0x8B)         // gzip header
+                                     || (b0 == 0x78 && (b1 == 0x01      // zlib header
+                                                        || b1 == 0x9C
+                                                        || b1 == 0xDA))));
+                }
+                if (is_text)
+                {
+                    // simply swap in_buff and out_buff, and adjust pointers
+                    assert(in_buff_start == in_buff);
+                    std::swap(in_buff, out_buff);
+                    out_buff_free_start = in_buff_end;
+                    in_buff_start = in_buff;
+                    in_buff_end = in_buff;
+                }
+                else
+                {
+                    // run inflate() on input
+                    if (! zstrm_p) zstrm_p = new detail::z_stream_wrapper(true);
+                    zstrm_p->next_in = reinterpret_cast< decltype(zstrm_p->next_in) >(in_buff_start);
+                    zstrm_p->avail_in = in_buff_end - in_buff_start;
+                    zstrm_p->next_out = reinterpret_cast< decltype(zstrm_p->next_out) >(out_buff_free_start);
+                    zstrm_p->avail_out = (out_buff + buff_size) - out_buff_free_start;
+                    int ret = inflate(zstrm_p, Z_NO_FLUSH);
+                    // process return code
+                    if (ret != Z_OK && ret != Z_STREAM_END) throw Exception(zstrm_p, ret);
+                    // update in&out pointers following inflate()
+                    in_buff_start = reinterpret_cast< decltype(in_buff_start) >(zstrm_p->next_in);
+                    in_buff_end = in_buff_start + zstrm_p->avail_in;
+                    out_buff_free_start = reinterpret_cast< decltype(out_buff_free_start) >(zstrm_p->next_out);
+                    assert(out_buff_free_start + zstrm_p->avail_out == out_buff + buff_size);
+                    // if stream ended, deallocate inflator
+                    if (ret == Z_STREAM_END)
+                    {
+                        delete zstrm_p;
+                        zstrm_p = nullptr;
+                    }
+                }
+            } while (out_buff_free_start == out_buff);
+            // 2 exit conditions:
+            // - end of input: there might or might not be output available
+            // - out_buff_free_start != out_buff: output available
+            this->setg(out_buff, out_buff, out_buff_free_start);
+        }
+        return this->gptr() == this->egptr()
+            ? traits_type::eof()
+            : traits_type::to_int_type(*this->gptr());
+    }
+private:
+    std::streambuf * sbuf_p;
+    char * in_buff;
+    char * in_buff_start;
+    char * in_buff_end;
+    char * out_buff;
+    detail::z_stream_wrapper * zstrm_p;
+    std::size_t buff_size;
+    bool auto_detect;
+    bool auto_detect_run;
+    bool is_text;
+
+    static const std::size_t default_buff_size = (std::size_t)1 << 20;
+}; // class istreambuf
+
+class ostreambuf
+    : public std::streambuf
+{
+public:
+    ostreambuf(std::streambuf * _sbuf_p,
+               std::size_t _buff_size = default_buff_size, int _level = Z_DEFAULT_COMPRESSION)
+        : sbuf_p(_sbuf_p),
+          zstrm_p(new detail::z_stream_wrapper(false, _level)),
+          buff_size(_buff_size)
+    {
+        assert(sbuf_p);
+        in_buff = new char [buff_size];
+        out_buff = new char [buff_size];
+        setp(in_buff, in_buff + buff_size);
+    }
+
+    ostreambuf(const ostreambuf &) = delete;
+    ostreambuf(ostreambuf &&) = default;
+    ostreambuf & operator = (const ostreambuf &) = delete;
+    ostreambuf & operator = (ostreambuf &&) = default;
+
+    int deflate_loop(int flush)
+    {
+        while (true)
+        {
+            zstrm_p->next_out = reinterpret_cast< decltype(zstrm_p->next_out) >(out_buff);
+            zstrm_p->avail_out = buff_size;
+            int ret = deflate(zstrm_p, flush);
+            if (ret != Z_OK && ret != Z_STREAM_END && ret != Z_BUF_ERROR) throw Exception(zstrm_p, ret);
+            std::streamsize sz = sbuf_p->sputn(out_buff, reinterpret_cast< decltype(out_buff) >(zstrm_p->next_out) - out_buff);
+            if (sz != reinterpret_cast< decltype(out_buff) >(zstrm_p->next_out) - out_buff)
+            {
+                // there was an error in the sink stream
+                return -1;
+            }
+            if (ret == Z_STREAM_END || ret == Z_BUF_ERROR || sz == 0)
+            {
+                break;
+            }
+        }
+        return 0;
+    }
+
+    virtual ~ostreambuf()
+    {
+        // flush the zlib stream
+        //
+        // NOTE: Errors here (sync() return value not 0) are ignored, because we
+        // cannot throw in a destructor. This mirrors the behaviour of
+        // std::basic_filebuf::~basic_filebuf(). To see an exception on error,
+        // close the ofstream with an explicit call to close(), and do not rely
+        // on the implicit call in the destructor.
+        //
+        sync();
+        delete [] in_buff;
+        delete [] out_buff;
+        delete zstrm_p;
+    }
+    virtual std::streambuf::int_type overflow(std::streambuf::int_type c = traits_type::eof())
+    {
+        zstrm_p->next_in = reinterpret_cast< decltype(zstrm_p->next_in) >(pbase());
+        zstrm_p->avail_in = pptr() - pbase();
+        while (zstrm_p->avail_in > 0)
+        {
+            int r = deflate_loop(Z_NO_FLUSH);
+            if (r != 0)
+            {
+                setp(nullptr, nullptr);
+                return traits_type::eof();
+            }
+        }
+        setp(in_buff, in_buff + buff_size);
+        return traits_type::eq_int_type(c, traits_type::eof()) ? traits_type::eof() : sputc(c);
+    }
+    virtual int sync()
+    {
+        // first, call overflow to clear in_buff
+        overflow();
+        if (! pptr()) return -1;
+        // then, call deflate asking to finish the zlib stream
+        zstrm_p->next_in = nullptr;
+        zstrm_p->avail_in = 0;
+        if (deflate_loop(Z_FINISH) != 0) return -1;
+        deflateReset(zstrm_p);
+        return 0;
+    }
+private:
+    std::streambuf * sbuf_p;
+    char * in_buff;
+    char * out_buff;
+    detail::z_stream_wrapper * zstrm_p;
+    std::size_t buff_size;
+
+    static const std::size_t default_buff_size = (std::size_t)1 << 20;
+}; // class ostreambuf
+
+class istream
+    : public std::istream
+{
+public:
+    istream(std::istream & is)
+        : std::istream(new istreambuf(is.rdbuf()))
+    {
+        exceptions(std::ios_base::badbit);
+    }
+    explicit istream(std::streambuf * sbuf_p)
+        : std::istream(new istreambuf(sbuf_p))
+    {
+        exceptions(std::ios_base::badbit);
+    }
+    virtual ~istream()
+    {
+        delete rdbuf();
+    }
+}; // class istream
+
+class ostream
+    : public std::ostream
+{
+public:
+    ostream(std::ostream & os)
+        : std::ostream(new ostreambuf(os.rdbuf()))
+    {
+        exceptions(std::ios_base::badbit);
+    }
+    explicit ostream(std::streambuf * sbuf_p)
+        : std::ostream(new ostreambuf(sbuf_p))
+    {
+        exceptions(std::ios_base::badbit);
+    }
+    virtual ~ostream()
+    {
+        delete rdbuf();
+    }
+}; // class ostream
+
+namespace detail
+{
+
+template < typename FStream_Type >
+struct strict_fstream_holder
+{
+    strict_fstream_holder(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
+        : _fs(filename, mode)
+    {}
+    FStream_Type _fs;
+}; // class strict_fstream_holder
+
+} // namespace detail
+
+class ifstream
+    : private detail::strict_fstream_holder< strict_fstream::ifstream >,
+      public std::istream
+{
+public:
+    explicit ifstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::in)
+        : detail::strict_fstream_holder< strict_fstream::ifstream >(filename, mode),
+          std::istream(new istreambuf(_fs.rdbuf()))
+    {
+        exceptions(std::ios_base::badbit);
+    }
+    virtual ~ifstream()
+    {
+        if (rdbuf()) delete rdbuf();
+    }
+}; // class ifstream
+
+class ofstream
+    : private detail::strict_fstream_holder< strict_fstream::ofstream >,
+      public std::ostream
+{
+public:
+    explicit ofstream(const std::string& filename, std::ios_base::openmode mode = std::ios_base::out)
+        : detail::strict_fstream_holder< strict_fstream::ofstream >(filename, mode | std::ios_base::binary),
+          std::ostream(new ostreambuf(_fs.rdbuf()))
+    {
+        exceptions(std::ios_base::badbit);
+    }
+    virtual ~ofstream()
+    {
+        if (rdbuf()) delete rdbuf();
+    }
+}; // class ofstream
+
+} // namespace zstr
+
+#endif
